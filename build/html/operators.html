<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Operators and Expressions &mdash; Modelica Language Specification 3.3 Revision 1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.3 Revision 1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Modelica Language Specification 3.3 Revision 1 documentation" href="index.html" />
    <link rel="prev" title="Lexical Structure" href="lexical.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="lexical.html" title="Lexical Structure"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Modelica Language Specification 3.3 Revision 1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="operators-and-expressions">
<h1>Operators and Expressions<a class="headerlink" href="#operators-and-expressions" title="Permalink to this headline">¶</a></h1>
<p>The lexical units are combined to form even larger building blocks such
as expressions according to the rules given by the expression part of
the Modelica grammar in <span class="xref std std-ref">TODO: Appendix B</span>.</p>
<p>This chapter describes the evaluation rules for expressions, the concept
of expression variability, built-in mathematical operators and
functions, and the built-in special Modelica operators with function
syntax.</p>
<p>Expressions can contain variables and constants, which have types,
predefined or user defined. The predefined built-in types of Modelica
are Real, Integer, Boolean, String, and enumeration types which are
presented in more detail in Section <span class="xref std std-ref">predefined-types</span>.
[<em>The abbreviated predefined
type information below is given as background information for the rest
of the presentation.</em>]</p>
<div class="section" id="expressions">
<h2>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h2>
<p>Modelica equations, assignments and declaration equations contain
expressions.</p>
<p>Expressions can contain basic operations, <code class="docutils literal highlight highlight-modelica"><span class="o">+</span><span class="p">,</span> <span class="o">-</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">^</span></code>, etc. with
normal precedence as defined in <a class="reference internal" href="#table-operators"><span>Table 1</span></a> and the grammar
in Section <span class="xref std std-ref">modelica-concrete-syntax</span>. The semantics of the operations is defined for both
scalar and array arguments in <span class="xref std std-ref">TODO: Section 10.6</span>.</p>
<p>It is also possible to define functions and call them in a normal
fashion. The function call syntax for both positional and named
arguments is described in <span class="xref std std-ref">TODO: Section 12.4.1</span> and for vectorized calls in
<span class="xref std std-ref">TODO: Section 12.4.4</span>. The built-in array functions are given in <span class="xref std std-ref">TODO: Section 10.1.1</span>
and other built-in operators in Section <a class="reference internal" href="#builtin-with-function-syntax"><span>Built-in Intrinsic Operators with Function Syntax</span></a>.</p>
</div>
<div class="section" id="operator-precedence-and-associativity">
<h2>Operator Precedence and Associativity<a class="headerlink" href="#operator-precedence-and-associativity" title="Permalink to this headline">¶</a></h2>
<p>Operator precedence determines the order of evaluation of operators in
an expression. An operator with higher precedence is evaluated before an
operator with lower precedence in the same expression.</p>
<p>The following table presents all the expression operators in order of
precedence from highest to lowest, as derived from the Modelica grammar
in <span class="xref std std-ref">TODO: Appendix B</span>. All operators are binary except the postfix operators and
those shown as unary together with <em>expr</em>, the conditional operator, the
array construction operator <code class="docutils literal highlight highlight-modelica"><span class="p">{}</span></code> and concatenation operator <code class="docutils literal highlight highlight-modelica"><span class="p">[]</span></code>, and the
array range constructor <code class="docutils literal highlight highlight-modelica"><span class="o">:</span></code> which is either binary or ternary. Operators
with the same precedence occur at the same line of the table:</p>
<table border="1" class="docutils" id="table-operators">
<caption><span class="caption-number">Table 1 </span><span class="caption-text">Operators.</span><a class="headerlink" href="#table-operators" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="32%" />
<col width="40%" />
<col width="28%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>Operator Group</em></td>
<td><em>Operator Syntax</em></td>
<td><em>Examples</em></td>
</tr>
<tr class="row-even"><td>postfix array index operator</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="p">[]</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">]</span></code></td>
</tr>
<tr class="row-odd"><td>postfix access operator</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="o">.</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="n">a</span><span class="o">.</span><span class="n">b</span></code></td>
</tr>
<tr class="row-even"><td>postfix function call</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="n">funcName</span><span class="p">(</span><span class="kr">function</span><span class="o">-</span><span class="n">arguments</span><span class="p">)</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="nb">sin</span><span class="p">(</span><span class="mf">4.36</span><span class="p">)</span></code></td>
</tr>
<tr class="row-odd"><td>array construct/concat</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="p">{</span><span class="n">expressions</span><span class="p">}</span></code>
<code class="docutils literal highlight highlight-modelica"><span class="p">[</span><span class="n">expressions</span><span class="p">]</span></code>
<code class="docutils literal highlight highlight-modelica"><span class="p">[</span><span class="n">expressions</span><span class="p">;</span> <span class="n">expressions</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span> <span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span></code>
<code class="docutils literal highlight highlight-modelica"><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span></code>
<code class="docutils literal highlight highlight-modelica"><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span></code></td>
</tr>
<tr class="row-even"><td>exponentiation</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="o">^</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="mi">2</span><span class="o">^</span><span class="mi">3</span></code></td>
</tr>
<tr class="row-odd"><td>multiplicative and array
elementwise multiplicative</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="o">*</span> <span class="o">/</span> <span class="o">.*</span> <span class="o">./</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="mi">2</span><span class="o">*</span><span class="mi">3</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span></code>
<code class="docutils literal highlight highlight-modelica"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">.*</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span></code></td>
</tr>
<tr class="row-even"><td>additive and array
elementwise additive</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="o">+</span> <span class="o">-</span> <span class="o">+</span><span class="n">expr</span> <span class="o">-</span><span class="n">expr</span> <span class="o">.+</span> <span class="o">.-</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="o">+</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">a</span></code>
<code class="docutils literal highlight highlight-modelica"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">.+</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">;</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span></code></td>
</tr>
<tr class="row-odd"><td>relational</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="o">&lt;</span> <span class="o">&lt;=</span> <span class="o">&gt;</span> <span class="o">&gt;=</span> <span class="o">==</span> <span class="o">&lt;&gt;</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">&lt;=</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="p">,</span> <span class="o">...</span></code></td>
</tr>
<tr class="row-even"><td>unary negation</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="ow">not</span> <span class="n">expr</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="ow">not</span> <span class="n">b1</span></code></td>
</tr>
<tr class="row-odd"><td>logical and</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="ow">and</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="n">b1</span> <span class="ow">and</span> <span class="n">b2</span></code></td>
</tr>
<tr class="row-even"><td>logical or</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="ow">or</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="n">b1</span> <span class="ow">or</span> <span class="n">b2</span></code></td>
</tr>
<tr class="row-odd"><td>array range</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="n">expr</span> <span class="o">:</span> <span class="n">expr</span></code>
<code class="docutils literal highlight highlight-modelica"><span class="n">expr</span> <span class="o">:</span> <span class="n">expr</span> <span class="o">:</span> <span class="n">expr</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="mi">1</span><span class="o">:</span><span class="mi">5</span></code>
<code class="docutils literal highlight highlight-modelica"><span class="n">start</span><span class="o">:</span><span class="n">step</span><span class="o">:</span><span class="n">stop</span></code></td>
</tr>
<tr class="row-even"><td>conditional</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="kr">if</span> <span class="n">expr</span> <span class="kr">then</span> <span class="n">expr</span> <span class="kr">else</span> <span class="n">expr</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="mi">3</span> <span class="kr">else</span> <span class="n">x</span></code></td>
</tr>
<tr class="row-odd"><td>named argument</td>
<td><code class="docutils literal highlight highlight-modelica"><span class="n">ident</span> <span class="o">=</span> <span class="n">expr</span></code></td>
<td><code class="docutils literal highlight highlight-modelica"><span class="n">x</span> <span class="o">=</span> <span class="mf">2.26</span></code></td>
</tr>
</tbody>
</table>
<p>The conditional operator may also include elseif-clauses. Equality = and
assignment := are not expression operators since they are allowed only
in equations and in assignment statements respectively. All binary
expression operators are left associative, except exponentiation which
is non-associative. The array range operator is non-associative.</p>
<p>[<em>The unary minus and plus in Modelica is slightly different than in
Mathematica and in MATLAB</em> <a class="footnote-reference" href="#matlab-mathematica" id="id1">[1]</a><em>, since the following expressions
are illegal (whereas in Mathematica and in MATLAB these are
valid expressions):</em></p>
<p><code class="docutils literal highlight highlight-modelica"><span class="mi">2</span><span class="o">*-</span><span class="mi">2</span> <span class="c1">// = -4</span></code> in Mathematica/MATLAB; is illegal in Modelica</p>
<p><code class="docutils literal highlight highlight-modelica"><span class="o">--</span><span class="mi">2</span> <span class="c1">// = 2</span></code> in Mathematica/MATLAB; is illegal in Modelica</p>
<p><code class="docutils literal highlight highlight-modelica"><span class="o">++</span><span class="mi">2</span> <span class="c1">// = 2</span></code> in Mathematica/MATLAB; is illegal in Modelica</p>
<p><code class="docutils literal highlight highlight-modelica"><span class="mi">2</span><span class="o">--</span><span class="mi">2</span> <span class="c1">// = 4</span></code> in Mathematica/MATLAB; is illegal in Modelica</p>
<p><em>Non-associative exponentation and array range operator:</em></p>
<p><code class="docutils literal highlight highlight-modelica"><span class="n">x</span><span class="o">^</span><span class="n">y</span><span class="o">^</span><span class="n">z</span></code> Not legal, use parenthesis to make it clear.</p>
<p><code class="docutils literal highlight highlight-modelica"><span class="n">a</span><span class="o">:</span><span class="n">b</span><span class="o">:</span><span class="n">c</span><span class="o">:</span><span class="n">d</span><span class="o">:</span><span class="n">e</span><span class="o">:</span><span class="n">f</span><span class="o">:</span><span class="n">g</span></code> Not legal, and scalar arguments gives no legal interpretation.</p>
<p>]</p>
</div>
<div class="section" id="evaluation-order">
<span id="id2"></span><h2>Evaluation Order<a class="headerlink" href="#evaluation-order" title="Permalink to this headline">¶</a></h2>
<p>A tool is free to solve equations, reorder expressions and to not
evaluate expressions if their values do not influence the result (e.g.
short-circuit evaluation of Boolean expressions). If-statements and
if-expressions guarantee that their clauses are only evaluated if the
appropriate condition is true, but relational operators generating state
or time events will during continuous integration have the value from
the most recent event.</p>
<p>If a numeric operation overflows the result is undefined. For literals
it is recommended to automatically convert the number to another type
with greater precision.</p>
<div class="section" id="example-guarding-expressions-against-incorrect-evaluation">
<h3>Example: Guarding Expressions Against Incorrect Evaluation<a class="headerlink" href="#example-guarding-expressions-against-incorrect-evaluation" title="Permalink to this headline">¶</a></h3>
<p>[<em>Example. If one wants to guard an expression against incorrect
evaluation, it should be guarded by an if:</em></p>
<div class="highlight-modelica"><div class="highlight"><pre>  <span class="nb">Boolean</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
  <span class="nb">Boolean</span> <span class="n">b</span><span class="p">;</span>
  <span class="nb">Integer</span> <span class="n">I</span><span class="p">;</span>
<span class="kr">equation</span>
  <span class="n">x</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">I</span><span class="o">&gt;=</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">I</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">);</span> <span class="c1">// Invalid</span>
  <span class="n">x</span><span class="o">=</span><span class="kr">if</span> <span class="p">(</span><span class="n">I</span><span class="o">&gt;=</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">I</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">)</span> <span class="kr">then</span> <span class="n">v</span><span class="p">[</span><span class="n">I</span><span class="p">]</span> <span class="kr">else</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// Correct</span>
</pre></div>
</div>
<p><em>To guard square against square root of negative number use</em>
noEvent<em>:</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">der</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">=</span><span class="kr">if</span> <span class="n">h</span><span class="o">&gt;</span><span class="mi">0</span> <span class="kr">then</span> <span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="nb">sqrt</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="kr">else</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Incorrect</span>
<span class="kr">der</span><span class="p">(</span><span class="n">h</span><span class="p">)</span><span class="o">=</span><span class="kr">if</span> <span class="nb">noEvent</span><span class="p">(</span><span class="n">h</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="kr">then</span> <span class="o">-</span><span class="n">c</span><span class="o">*</span><span class="nb">sqrt</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="kr">else</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Correct</span>
</pre></div>
</div>
<p>]</p>
</div>
</div>
<div class="section" id="arithmetic-operators">
<h2>Arithmetic Operators<a class="headerlink" href="#arithmetic-operators" title="Permalink to this headline">¶</a></h2>
<p>Modelica supports five binary arithmetic operators that operate on any
numerical type:</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="o">^</span></code></td>
<td>Exponentiation</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="o">*</span></code></td>
<td>Multiplication</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="o">/</span></code></td>
<td>Division</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="o">+</span></code></td>
<td>Addition</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="o">-</span></code></td>
<td>Subtraction</td>
</tr>
</tbody>
</table>
<p>Some of these operators can also be applied to a combination of a scalar
type and an array type, see Section <span class="xref std std-ref">TODO: 10.6</span>.</p>
<p>The syntax of these operators is defined by the following rules from the
Modelica grammar:</p>
<div class="highlight-ebnf"><div class="highlight"><pre><span class="k">arithmetic_expression </span><span class="o">=</span>
  <span class="p">[</span> <span class="k">add_op </span><span class="p">]</span> <span class="k">term </span><span class="p">{</span> <span class="k">add_op term </span><span class="p">}</span> <span class="p">;</span>

<span class="k">add_op </span><span class="o">=</span>
  <span class="s2">&quot;+&quot;</span> <span class="p">|</span> <span class="s2">&quot;-&quot;</span> <span class="p">;</span>

<span class="k">term </span><span class="o">=</span>
  <span class="k">factor </span><span class="p">{</span> <span class="k">mul_op factor </span><span class="p">}</span> <span class="p">;</span>

<span class="k">mul_op </span><span class="o">=</span>
  <span class="s2">&quot;*&quot;</span> <span class="p">|</span> <span class="s2">&quot;/&quot;</span> <span class="p">;</span>

<span class="k">factor </span><span class="o">=</span>
  <span class="k">primary </span><span class="p">[</span> <span class="s2">&quot;^&quot;</span> <span class="k">primary </span><span class="p">]</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="equality-relational-and-logical-operators">
<span id="eq-relational-logic-operators"></span><h2>Equality, Relational, and Logical Operators<a class="headerlink" href="#equality-relational-and-logical-operators" title="Permalink to this headline">¶</a></h2>
<p>Modelica supports the standard set of relational and logical operators,
all of which produce the standard boolean values true or false.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="o">&gt;</span></code></td>
<td>greater than</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="o">&gt;=</span></code></td>
<td>greater than or equal</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="o">&lt;</span></code></td>
<td>less than</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="o">&lt;=</span></code></td>
<td>less than or equal to</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="o">==</span></code></td>
<td>equality within expressions</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="o">&lt;&gt;</span></code></td>
<td>Inequality</td>
</tr>
</tbody>
</table>
<p>A single equals sign <code class="docutils literal highlight highlight-modelica"><span class="o">=</span></code> is never used in relational expressions, only in
equations (<span class="xref std std-ref">TODO: Chapter 8, Section 10.6.1</span>) and in function calls using named
parameter passing (<span class="xref std std-ref">TODO: Section 12.4.1</span>).</p>
<p>The following logical operators are defined:</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="72%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="ow">not</span></code></td>
<td>negation, unary operator</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="ow">and</span></code></td>
<td>logical and</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="ow">or</span></code></td>
<td>logical or</td>
</tr>
</tbody>
</table>
<p>The grammar rules define the syntax of the relational and logical
operators.</p>
<div class="highlight-ebnf"><div class="highlight"><pre><span class="k">logical_expression </span><span class="o">=</span>
  <span class="k">logical_term </span><span class="p">{</span> <span class="k">or logical_term </span><span class="p">}</span> <span class="p">;</span>
<span class="k">logical_term </span><span class="o">=</span>
  <span class="k">logical_factor </span><span class="p">{</span> <span class="k">and logical_factor </span><span class="p">}</span> <span class="p">;</span>
<span class="k">logical_factor </span><span class="o">=</span>
  <span class="p">[</span> <span class="k">not </span><span class="p">]</span> <span class="k">relation </span><span class="p">;</span>
<span class="k">relation </span><span class="o">=</span>
  <span class="k">arithmetic_expression </span><span class="p">[</span> <span class="k">rel_op arithmetic_expression </span><span class="p">]</span> <span class="p">;</span>
<span class="k">rel_op </span><span class="o">=</span>
  <span class="s2">&quot;&lt;&quot;</span> <span class="p">|</span> <span class="p">(</span> <span class="s2">&quot;&lt;=&quot;</span> <span class="p">)</span> <span class="p">|</span> <span class="s2">&quot;&gt;&quot;</span> <span class="p">|</span> <span class="p">(</span> <span class="s2">&quot;&gt;=&quot;</span> <span class="p">)</span> <span class="p">|</span> <span class="p">(</span> <span class="s2">&quot;==&quot;</span> <span class="p">)</span> <span class="p">|</span> <span class="p">(</span> <span class="s2">&quot;&lt;&gt;&quot;</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>The following holds for relational operators:</p>
<ul class="simple">
<li>Relational operators <code class="docutils literal highlight highlight-modelica"><span class="o">&lt;</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="o">&lt;=</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="o">&gt;</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="o">&gt;=</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="o">==</span></code>, &lt;&gt;``, are only defined for
scalar operands of simple types. The result is Boolean and is <code class="docutils literal highlight highlight-modelica"><span class="kc">true</span></code> or
<code class="docutils literal highlight highlight-modelica"><span class="kc">false</span></code> if the relation is fulfilled or not, respectively.</li>
<li>For operands of type String, str1 op str2 is for each relational
operator, op, defined in terms of the C-function strcmp as
strcmp(str1,str2) op 0.</li>
<li>For operands of type Boolean, <code class="docutils literal highlight highlight-modelica"><span class="kc">false</span><span class="o">&lt;</span><span class="kc">true</span></code>.</li>
<li>For operands of enumeration types, the order is given by the order of
declaration of the enumeration literals.</li>
<li>In relations of the form <code class="docutils literal highlight highlight-modelica"><span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span></code> or <code class="docutils literal highlight highlight-modelica"><span class="n">v1</span> <span class="o">&lt;&gt;</span> <span class="n">v2</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="n">v1</span> <span class="ow">or</span> <span class="n">v2</span></code> shall, unless
used in a function, not be a subtype of Real. [<em>The reason for this
rule is that relations with Real arguments are transformed to state
events (see Events, Section</em> 8.5<em>) and this transformation becomes
unnecessarily complicated for the == and &lt;&gt; relational operators
(e.g. two crossing functions instead of one crossing function needed,
epsilon strategy needed even at event instants). Furthermore, testing
on equality of Real variables is questionable on machines where the
number length in registers is different to number length in main
memory</em>].</li>
<li>Relations of the form <code class="docutils literal highlight highlight-modelica"><span class="n">v1</span> <span class="n">rel_op</span> <span class="n">v2</span></code>, with v1 and v2 variables and
rel_op a relational operator are called elementary relations. If
either v1 or v2 or both variables are a subtype of Real, the relation
is called a Real elementary relation.</li>
</ul>
</div>
<div class="section" id="miscellaneous-operators-and-variables">
<h2>Miscellaneous Operators and Variables<a class="headerlink" href="#miscellaneous-operators-and-variables" title="Permalink to this headline">¶</a></h2>
<p>Modelica also contains a few built-in operators which are not standard
arithmetic, relational, or logical operators. These are described below,
including time, which is a built-in variable, not an operator.</p>
<div class="section" id="string-concatenation">
<h3>String Concatenation<a class="headerlink" href="#string-concatenation" title="Permalink to this headline">¶</a></h3>
<p>Concatenation of strings (see the Modelica grammar) is denoted by the +
operator in Modelica [<em>e.g.</em> <code class="docutils literal highlight highlight-modelica"><span class="s2">&quot;a&quot;</span> <span class="o">+</span> <span class="s2">&quot;b&quot;</span></code> <em>becomes</em> <code class="docutils literal highlight highlight-modelica"><span class="s2">&quot;ab&quot;</span></code>].</p>
</div>
<div class="section" id="array-constructor-operator">
<h3>Array Constructor Operator<a class="headerlink" href="#array-constructor-operator" title="Permalink to this headline">¶</a></h3>
<p>The array constructor operator <code class="docutils literal highlight highlight-modelica"><span class="p">{</span> <span class="o">...</span> <span class="p">}</span></code> is described in <span class="xref std std-ref">TODO: Section 10.4</span>.</p>
</div>
<div class="section" id="array-concatenation-operator">
<h3>Array Concatenation Operator<a class="headerlink" href="#array-concatenation-operator" title="Permalink to this headline">¶</a></h3>
<p>The array concatenation operator <code class="docutils literal highlight highlight-modelica"><span class="p">[</span> <span class="o">...</span> <span class="p">]</span></code> is described in <span class="xref std std-ref">TODO: Section 10.4.2</span>.</p>
</div>
<div class="section" id="array-range-operator">
<h3>Array Range Operator<a class="headerlink" href="#array-range-operator" title="Permalink to this headline">¶</a></h3>
<p>The array range constructor operator <code class="docutils literal highlight highlight-modelica"><span class="o">:</span></code> is described in <span class="xref std std-ref">TODO: Section 10.4.3</span>.</p>
</div>
<div class="section" id="if-expressions">
<h3>If-Expressions<a class="headerlink" href="#if-expressions" title="Permalink to this headline">¶</a></h3>
<p>An expression</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">if</span> <span class="n">expression1</span> <span class="kr">then</span> <span class="n">expression2</span> <span class="kr">else</span> <span class="n">expression3</span>
</pre></div>
</div>
<p>is one example of if-expression. First expression1, which must be
boolean expression, is evaluated. If expression1 is true expression2 is
evaluated and is the value of the if-expression, else expression3 is
evaluated and is the value of the if-expression. The two expressions,
expression2 and expression3, must be type compatible expressions
(<span class="xref std std-ref">TODO: Section 6.6</span>) giving the type of the if-expression. If-expressions with
elseif are defined by replacing elseif by else if. [<em>Note:</em> elseif <em>has
been added for symmetry with if-clauses.</em>] For short-circuit evaluation
see Section <a class="reference internal" href="#evaluation-order"><span>Evaluation Order</span></a>.</p>
<p>[<em>Example</em>:</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="nb">Integer</span> <span class="n">i</span><span class="p">;</span>
<span class="nb">Integer</span> <span class="n">sign_of_i1</span><span class="o">=</span><span class="kr">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="kr">then</span> <span class="o">-</span><span class="mi">1</span> <span class="kr">elseif</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="nb">Integer</span> <span class="n">sign_of_i2</span><span class="o">=</span><span class="kr">if</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="kr">then</span> <span class="o">-</span><span class="mi">1</span> <span class="kr">else</span> <span class="kr">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>]</p>
</div>
<div class="section" id="member-access-operator">
<h3>Member Access Operator<a class="headerlink" href="#member-access-operator" title="Permalink to this headline">¶</a></h3>
<p>It is possible to access members of a class instance using dot notation,
i.e., the <code class="docutils literal highlight highlight-modelica"><span class="o">.</span></code> operator.</p>
<p>[<em>Example:</em> <code class="docutils literal highlight highlight-modelica"><span class="n">R1</span><span class="o">.</span><span class="n">R</span></code> <em>for accessing the resistance component</em> <code class="docutils literal highlight highlight-modelica"><span class="n">R</span></code> <em>of
resistor</em> <code class="docutils literal highlight highlight-modelica"><span class="n">R1</span></code> <em>. Another use of dot notation: local classes which are
members of a class can of course also be accessed using dot notation on
the name of the class, not on instances of the class.</em>]</p>
</div>
<div class="section" id="built-in-variable-time">
<h3>Built-in Variable time<a class="headerlink" href="#built-in-variable-time" title="Permalink to this headline">¶</a></h3>
<p>All declared variables are functions of the independent variable time.
The variable time is a built-in variable available in all models and
blocks, which is treated as an input variable. It is implicitly defined
as:</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">input</span> <span class="nb">Real</span> <span class="nb">time</span> <span class="p">(</span><span class="kr">final</span> <span class="n">quantity</span> <span class="o">=</span> <span class="s2">&quot;Time&quot;</span><span class="p">,</span> <span class="kr">final</span> <span class="n">unit</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The value of the start attribute of time is set to the time instant at
which the simulation is started.</p>
<p>[<em>Example</em>:</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">encapsulated</span> <span class="kr">model</span> <span class="nc">SineSource</span>
  <span class="kr">import</span> <span class="n">Modelica</span><span class="o">.</span><span class="n">Math</span><span class="o">.</span><span class="nb">sin</span><span class="p">;</span>
  <span class="kr">connector</span> <span class="nc">OutPort</span><span class="o">=</span><span class="kr">output</span> <span class="nb">Real</span><span class="p">;</span>
  <span class="n">OutPort</span> <span class="n">y</span><span class="o">=</span><span class="nb">sin</span><span class="p">(</span><span class="nb">time</span><span class="p">);</span> <span class="c1">// Uses the built-in variable time.</span>
<span class="kr">end</span> <span class="nc">SineSource</span><span class="p">;</span>
</pre></div>
</div>
<p>]</p>
</div>
</div>
<div class="section" id="built-in-intrinsic-operators-with-function-syntax">
<span id="builtin-with-function-syntax"></span><h2>Built-in Intrinsic Operators with Function Syntax<a class="headerlink" href="#built-in-intrinsic-operators-with-function-syntax" title="Permalink to this headline">¶</a></h2>
<p>Certain built-in operators of Modelica have the same syntax as a
function call. However, they do not behave as a mathematical function,
because the result depends not only on the input arguments but also on
the status of the simulation.</p>
<p>There are also built-in functions that depend only on the input
argument, but also may trigger events in addition to returning a value.
Intrinsic means that they are defined at the Modelica language level,
not in the Modelica library. The following built-in intrinsic
operators/functions are available:</p>
<ul class="simple">
<li>Mathematical functions and conversion functions, see Section <a class="reference internal" href="#numeric-and-conversion-functions"><span>Numeric Functions and Conversion Functions</span></a>
below.</li>
<li>Derivative and special purpose operators with function syntax, see
Section <a class="reference internal" href="#derivative-special-purpose-operators"><span>Derivative and Special Purpose Operators with Function Syntax</span></a> below.</li>
<li>Event-related operators with function syntax, see Section <a class="reference internal" href="#event-related-operators"><span>Event-Related Operators with Function Syntax</span></a>
below.</li>
<li>Array operators/functions, see Section <span class="xref std std-ref">TODO: 10.1.1</span>.</li>
</ul>
<p>With exception of built-in operator <code class="docutils literal highlight highlight-modelica"><span class="nb">String</span><span class="p">(</span><span class="o">...</span><span class="p">)</span></code>, all operators in this
section can only be called with positional arguments.</p>
<div class="section" id="numeric-functions-and-conversion-functions">
<span id="numeric-and-conversion-functions"></span><h3>Numeric Functions and Conversion Functions<a class="headerlink" href="#numeric-functions-and-conversion-functions" title="Permalink to this headline">¶</a></h3>
<p>The following mathematical operators and functions, also including some
conversion functions, are predefined in Modelica, and are vectorizable
according to Section 12.4.6, except for the String function. The
functions which do not trigger events are described in the table below,
whereas the event-triggering mathematical functions are described in
Section <a class="reference internal" href="#event-triggering-math-functions"><span>Event Triggering Mathematical Functions</span></a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></code></td>
<td>Is expanded into <code class="docutils literal highlight highlight-modelica">noEvent(if v &gt;= 0 then v else –v)</code>. Argument v needs to be an Integer or Real expression.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">sign</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></code></td>
<td>Is expanded into <code class="docutils literal highlight highlight-modelica">noEvent(if v&gt;0 then 1 else if v&lt;0 then –1 else 0)</code>. Argument v needs to be an Integer or Real expression.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></code></td>
<td>Returns the square root of <code class="docutils literal highlight highlight-modelica"><span class="n">v</span></code> if <code class="docutils literal highlight highlight-modelica"><span class="n">v</span><span class="o">&gt;=</span><span class="mi">0</span></code>, otherwise an error occurs. Argument <code class="docutils literal highlight highlight-modelica"><span class="n">v</span></code> needs to be an Integer or Real expression.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">Integer</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></code></td>
<td>Returns the ordinal number of the expression e of enumeration type that evaluates to the enumeration value E.enumvalue, where <code class="docutils literal highlight highlight-modelica">Integer(E.e1)``=1, ``Integer(E.en)``=n, for an enumeration ``type E=enumeration(e1, ..., en)</code>. See also Section <span class="xref std std-ref">TODO 4.8.5.2</span>.</td>
</tr>
<tr class="row-odd"><td><div class="first line-block">
<div class="line"><code class="docutils literal highlight highlight-modelica"><span class="nb">String</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">options</span><span class="o">&gt;</span><span class="p">)</span></code></div>
<div class="line"><code class="docutils literal highlight highlight-modelica"><span class="nb">String</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">options</span><span class="o">&gt;</span><span class="p">)</span></code></div>
<div class="line"><code class="docutils literal highlight highlight-modelica"><span class="nb">String</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">significantDigits</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">options</span><span class="o">&gt;</span><span class="p">)</span></code></div>
</div>
<div class="last line-block">
<div class="line"><code class="docutils literal highlight highlight-modelica"><span class="nb">String</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="n">s</span><span class="p">)</span></code></div>
<div class="line"><code class="docutils literal highlight highlight-modelica"><span class="nb">String</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">options</span><span class="o">&gt;</span><span class="p">)</span></code></div>
</div>
</td>
<td><p class="first">Convert a scalar non-String expression to a String representation. The first argument may be a <code class="docutils literal highlight highlight-modelica"><span class="nb">Boolean</span> <span class="n">b</span></code>, an <code class="docutils literal highlight highlight-modelica"><span class="nb">Integer</span> <span class="n">i</span></code>, a <code class="docutils literal highlight highlight-modelica"><span class="nb">Real</span> <span class="n">r</span></code> or an <code class="docutils literal highlight highlight-modelica"><span class="n">Enumeration</span> <span class="n">e</span></code> (Section <span class="xref std std-ref">TODO: 4.8.5.2</span>). The other arguments must use named arguments. The optional &lt;options&gt; are:</p>
<p>Integer minimumLength=0: minimum length of the resulting string. If necessary, the blank character is used to fill up unused space.
Boolean leftJustified = true: if true, the converted result is left justified in the string; if false it is right justified in the string.
For Real expressions the output shall be according to the Modelica grammar. Integer significantDigits=6: defines the number of significant digits in the result string. [<em>Examples:</em> <code class="docutils literal highlight highlight-modelica"><span class="s2">&quot;12.3456&quot;</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="s2">&quot;0.0123456&quot;</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="s2">&quot;12345600&quot;</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="s2">&quot;1.23456E-10&quot;</span></code>].</p>
<p>The format string corresponding to options is:</p>
<ul class="simple">
<li>for Reals:&nbsp;<code class="docutils literal highlight highlight-modelica"><span class="p">(</span><span class="kr">if</span> <span class="n">leftJustified</span> <span class="kr">then</span> <span class="s2">&quot;-&quot;</span> <span class="kr">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">+</span><span class="nb">String</span><span class="p">(</span><span class="n">minimumLength</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.&quot;</span><span class="o">+</span> <span class="nb">String</span><span class="p">(</span><span class="n">signficantDigits</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;g&quot;</span></code>,</li>
<li>for Integers:&nbsp;<code class="docutils literal highlight highlight-modelica"><span class="p">(</span><span class="kr">if</span> <span class="n">leftJustified</span> <span class="kr">then</span> <span class="s2">&quot;-&quot;</span> <span class="kr">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">+</span><span class="nb">String</span><span class="p">(</span><span class="n">minimumLength</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;d&quot;</span></code>.</li>
</ul>
<p class="last">Format string: According to ANSI-C the format string specifies one conversion specifier (excluding the leading %), may not contain length modifiers, and may not use &#8220;*&#8221; for width and/or precision. For&nbsp;all numeric values&nbsp;the&nbsp;format specifiers&nbsp;f, e, E, g,&nbsp;G are allowed. For integral values&nbsp;it is also allowed to&nbsp;use the&nbsp;d, i, o, x, X, u, and c-format specifiers (for non-integral values a tool may&nbsp;round, truncate or use a different format if the integer conversion characters are used).
The x,X-formats (hexa-decimal)&nbsp;and c (character) for Integers does not lead to input&nbsp;that agrees with the Modelica-grammar.</p>
</td>
</tr>
</tbody>
</table>
<div class="section" id="event-triggering-mathematical-functions">
<span id="event-triggering-math-functions"></span><h4>Event Triggering Mathematical Functions<a class="headerlink" href="#event-triggering-mathematical-functions" title="Permalink to this headline">¶</a></h4>
<p>The built-in operators in this section trigger state events if used
outside of a when-clause and outside of a clocked discrete-time
partition (see Section 16.8.1). [ <em>If this is not desired, the</em> noEvent
<em>function can be applied to them. E.g.</em> noEvent(integer(v)) ]</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="96%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></code></td>
<td>Returns the algebraic quotient x/y with any fractional part discarded (also known as truncation toward zero). [<em>Note: this is defined for / in C99; in C89 the result for negative numbers is implementation-defined, so the standard function div() must be used.</em>]. Result and arguments shall have type Real or Integer. If either of the arguments is Real the result is Real otherwise Integer.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></code></td>
<td>Returns the integer modulus of x/y, i.e. mod(x,y)=x-floor(x/y)*y. Result and arguments shall have type Real or Integer. If either of the arguments is Real the result is Real otherwise Integer. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously. Examples</em> mod(3,1.4)=0.2<em>,</em> mod(-3,1.4)=1.2<em>,</em> mod(3,-1.4)=-1.2]</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">rem</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></code></td>
<td>Returns the integer remainder of x/y, such that div(x,y)*y + rem(x, y) = x. Result and arguments shall have type Real or Integer. If either of the arguments is Real the result is Real otherwise Integer. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously. Examples</em> rem(3,1.4)=0.2<em>,</em> rem(-3,1.4)=-0.2]</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>Returns the smallest integer not less than x. Result and argument shall have type Real. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously.</em>]</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>Returns the largest integer not greater than x. Result and argument shall have type Real. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously.</em>].</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">integer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>Returns the largest integer not greater than x. The argument shall have type Real. The result has type Integer.
[<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously.</em>].</td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">This is using an alternative to using a table: headings. There are other alternatives (like definition lists).
Using headers makes it easy to get permanent links to the text.</p>
</div>
<div class="section" id="div-x-y">
<span id="operator-div"></span><h5>div(x,y)<a class="headerlink" href="#div-x-y" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal highlight highlight-modelica"><span class="nb">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></code> returns the algebraic quotient x/y with any fractional part discarded (also known as truncation toward zero). [<em>Note: this is defined for / in C99; in C89 the result for negative numbers is implementation-defined, so the standard function div() must be used.</em>]. Result and arguments shall have type Real or Integer. If either of the arguments is Real the result is Real otherwise Integer.</p>
</div>
<div class="section" id="mod-x-y">
<span id="operator-mod"></span><h5>mod(x,y)<a class="headerlink" href="#mod-x-y" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal highlight highlight-modelica"><span class="nb">mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></code> returns the integer modulus of x/y, i.e. mod(x,y)=x-floor(x/y)*y. Result and arguments shall have type Real or Integer. If either of the arguments is Real the result is Real otherwise Integer. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously. Examples</em> mod(3,1.4)=0.2<em>,</em> mod(-3,1.4)=1.2<em>,</em> mod(3,-1.4)=-1.2].</p>
</div>
<div class="section" id="rem-x-y">
<span id="operator-rem"></span><h5>rem(x,y)<a class="headerlink" href="#rem-x-y" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal highlight highlight-modelica"><span class="nb">rem</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></code> returns the integer remainder of x/y, such that div(x,y)*y + rem(x, y) = x. Result and arguments shall have type Real or Integer. If either of the arguments is Real the result is Real otherwise Integer. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously. Examples</em> rem(3,1.4)=0.2<em>,</em> rem(-3,1.4)=-0.2].</p>
</div>
<div class="section" id="ceil-x">
<span id="operator-ceil"></span><h5>ceil(x)<a class="headerlink" href="#ceil-x" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal highlight highlight-modelica"><span class="nb">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> returns the smallest integer not less than x. Result and argument shall have type Real. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously.</em>].</p>
</div>
<div class="section" id="floor-x">
<span id="operator-floor"></span><h5>floor(x)<a class="headerlink" href="#floor-x" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal highlight highlight-modelica"><span class="nb">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> returns the largest integer not greater than x. Result and argument shall have type Real. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously.</em>].</p>
</div>
<div class="section" id="integer-x">
<span id="operator-integer"></span><h5>integer(x)<a class="headerlink" href="#integer-x" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal highlight highlight-modelica"><span class="nb">integer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code> returns the largest integer not greater than x. The argument shall have type Real. The result has type Integer.
[<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously.</em>].</p>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">This is using an alternative to using a table: definition lists.</p>
</div>
<dl class="docutils">
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">div</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></code></dt>
<dd>returns the algebraic quotient x/y with any fractional part discarded (also known as truncation toward zero). [<em>Note: this is defined for / in C99; in C89 the result for negative numbers is implementation-defined, so the standard function div() must be used.</em>]. Result and arguments shall have type Real or Integer. If either of the arguments is Real the result is Real otherwise Integer.</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">mod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></code></dt>
<dd>returns the integer modulus of x/y, i.e. mod(x,y)=x-floor(x/y)*y. Result and arguments shall have type Real or Integer. If either of the arguments is Real the result is Real otherwise Integer. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously. Examples</em> mod(3,1.4)=0.2<em>,</em> mod(-3,1.4)=1.2<em>,</em> mod(3,-1.4)=-1.2].</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">rem</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span></code></dt>
<dd>returns the integer remainder of x/y, such that div(x,y)*y + rem(x, y) = x. Result and arguments shall have type Real or Integer. If either of the arguments is Real the result is Real otherwise Integer. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously. Examples</em> rem(3,1.4)=0.2<em>,</em> rem(-3,1.4)=-0.2].</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></dt>
<dd>returns the smallest integer not less than x. Result and argument shall have type Real. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously.</em>].</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></dt>
<dd>returns the largest integer not greater than x. Result and argument shall have type Real. [<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously.</em>].</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">integer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></dt>
<dd>returns the largest integer not greater than x. The argument shall have type Real. The result has type Integer.
[<em>Note, outside of a when-clause state events are triggered when the return value changes discontinuously.</em>].</dd>
</dl>
</div>
</div>
<div class="section" id="built-in-mathematical-functions-and-external-built-in-functions">
<h4>Built-in Mathematical Functions and External Built-in Functions<a class="headerlink" href="#built-in-mathematical-functions-and-external-built-in-functions" title="Permalink to this headline">¶</a></h4>
<p>The following built-in mathematical functions are available in Modelica
and can be called directly without any package prefix added to the
function name. They are also available as external built-in functions in
the Modelica.Math library.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>sine</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>cosine</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">tan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>tangent (x shall not be: ..., -π/2, π/2, 3π/2, ...)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">asin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>inverse sine (-1 ≤ x ≤ 1)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">acos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>inverse cosine (-1 ≤ x ≤ 1)</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">atan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>inverse tangent</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">atan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></code></td>
<td>the <code class="docutils literal highlight highlight-modelica"><span class="nb">atan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></code> function calculates the principal value of the arc tangent of <code class="docutils literal highlight highlight-modelica"><span class="n">y</span><span class="o">/</span><span class="n">x</span></code>, using the signs of the
two arguments to determine the quadrant of the result</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">sinh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>hyperbolic sine</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">cosh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>hyperbolic cosine</td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">tanh</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>hyperbolic tangent</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>exponential, base <em>e</em></td>
</tr>
<tr class="row-even"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>natural (base <em>e</em>) logarithm (<code class="docutils literal highlight highlight-modelica"><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span></code>)</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal highlight highlight-modelica"><span class="nb">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></td>
<td>base 10 logarithm (<code class="docutils literal highlight highlight-modelica"><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span></code>)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="derivative-and-special-purpose-operators-with-function-syntax">
<span id="derivative-special-purpose-operators"></span><h3>Derivative and Special Purpose Operators with Function Syntax<a class="headerlink" href="#derivative-and-special-purpose-operators-with-function-syntax" title="Permalink to this headline">¶</a></h3>
<p>The following derivative operator and special purpose operators with
function syntax are predefined:</p>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">This is using a definition list for the operators. There are other alternatives (tables are not that nice).
Definition lists can be referred to using links, like <a class="reference internal" href="#operator-der"><span>der(expr)</span></a>, but the link will
not be visible in the HTML. Could possibly be themed into the HTML in some way.</p>
</div>
<dl class="docutils" id="operator-der">
<dt><code class="docutils literal highlight highlight-modelica"><span class="kr">der</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span></code></dt>
<dd>The time derivative of expr. If the expression expr is a scalar it
needs to be a subtype of Real. The expression and all its subexpressions
must be differentiable. If expr is an array, the operator is applied
to all elements of the array. For non-scalar arguments the function is
vectorized according to Section <span class="xref std std-ref">TODO: 10.6.12</span>.
[<em>For Real parameters and constants the result is a zero scalar or array of the same size as the variable.</em>]</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">delay</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="n">delayTime</span><span class="p">,</span> <span class="n">delayMax</span><span class="p">)</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="nb">delay</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span><span class="n">delayTime</span><span class="p">)</span></code></dt>
<dd>Returns: expr(time–delayTime) for&nbsp;time&gt;time.start + delayTime and
expr(time.start) for time &lt;= time.start + delayTime.
The arguments, i.e., expr, delayTime and delayMax, need to be subtypes of Real.
DelayMax needs to be additionally a parameter expression.
The following relation shall hold: 0 &lt;= delayTime &lt;= delayMax, otherwise an error occurs.
If delayMax is not supplied in the argument list, delayTime need to be a parameter expression.
See also Section <a class="reference internal" href="#operator-delay"><span>delay</span></a>. For non-scalar arguments the function is vectorized according to Section <span class="xref std std-ref">TODO: 10.6.12</span>.</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">cardinality</span><span class="p">(</span><span class="n">c</span><span class="p">)</span></code></dt>
<dd>[<em>This is a deprecated operator. It should no longer be used, since it will be removed in one of the next Modelica releases.</em>]
Returns the number of (inside and outside) occurrences of connector instance c in a connect-equation as an Integer number. See also Section <a class="reference internal" href="#operator-cardinality"><span>cardinality (deprecated)</span></a>.</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">homotopy</span><span class="p">(</span><span class="n">actual</span><span class="o">=</span><span class="n">actual</span><span class="p">,</span> <span class="n">simplified</span><span class="o">=</span><span class="n">simplified</span><span class="p">)</span></code></dt>
<dd><p class="first">The scalar expressions “actual” and “simplified” are subtypes of Real. A Modelica translator should map this operator into either of the two forms:</p>
<ol class="arabic simple">
<li>Returns “actual” <em>[a trivial implementation]</em>.</li>
<li>In order to solve algebraic systems of equations, the operator might during the solution process return a combination of the two arguments, ending at actual, <em>[e.g., actual*lambda + simplified*(1-lambda), where lambda is a homotopy parameter going from 0 to 1].</em></li>
</ol>
<p class="last">The solution must fulfill the equations for homotopy returning <code class="docutils literal highlight highlight-modelica"><span class="n">actual</span></code>.
See also Section <a class="reference internal" href="#operator-homotopy"><span>homotopy</span></a>. For non-scalar arguments the function is vectorized according to Section <span class="xref std std-ref">TODO: 12.4.6</span>.</p>
</dd>
</dl>
<dl class="docutils" id="operator-def-semilinear">
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">semiLinear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">positiveSlope</span><span class="p">,</span> <span class="n">negativeSlope</span><span class="p">)</span></code></dt>
<dd>Returns:
<code class="docutils literal highlight highlight-modelica"><span class="kr">if</span> <span class="n">x</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="kr">then</span> <span class="n">positiveSlope</span><span class="o">*</span><span class="n">x</span> <span class="kr">else</span> <span class="n">negativeSlope</span><span class="o">*</span><span class="n">x</span></code>.
The result is of type Real. See Section <a class="reference internal" href="#operator-semilinear"><span>semiLinear</span></a> [<em>especially in the case when x = 0</em>].
For non-scalar arguments the function is vectorized according to Section <span class="xref std std-ref">TODO: 10.6.12</span>.</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">inStream</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></code></dt>
<dd>The operator <code class="docutils literal highlight highlight-modelica"><span class="nb">inStream</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></code> is only allowed on stream variables v
defined in stream connectors, and is the value of the stream variable v
close to the connection point assuming that the flow is from the
connection point into the component.
This value is computed from the stream connection equations of the flow
variables and of the stream variables. The operator is vectorizable.
For more details see Section <span class="xref std std-ref">TODO: 15.2</span>.</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">actualStream</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></code></dt>
<dd>The actualStream(v) operator returns the actual value of the stream variable v for any flow direction. The operator is vectorizable. For more details, see Section <span class="xref std std-ref">TODO: 15.3</span>.</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">spatialDistribution</span><span class="p">(</span><span class="n">in0</span><span class="p">,</span> <span class="n">in1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="n">iP</span><span class="p">,</span> <span class="n">iV</span><span class="p">)</span></code></dt>
<dd>The <code class="docutils literal highlight highlight-modelica"><span class="nb">spatialDistribution</span><span class="p">(</span><span class="o">...</span><span class="p">)</span></code> operator allows approximation of variable-speed transport of properties, see Section <a class="reference internal" href="#operator-spatialdistribution"><span>spatialDistribution</span></a>.</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">getInstanceName</span><span class="p">()</span></code></dt>
<dd>Returns a string with the name of the model/block that is simulated, appended with the fully qualified name of the instance in which this function is called, see Section <a class="reference internal" href="#operator-instancename"><span>getInstanceName</span></a>.</dd>
</dl>
<p>A few of these operators are described in more detail in the following.</p>
<div class="section" id="delay">
<span id="operator-delay"></span><h4>delay<a class="headerlink" href="#delay" title="Permalink to this headline">¶</a></h4>
<p>[<em>The</em> <code class="docutils literal highlight highlight-modelica"><span class="nb">delay</span><span class="p">()</span></code> <em>operator allows a numerical sound implementation by
interpolating in the (internal) integrator polynomials, as well as a
more simple realization by interpolating linearly in a buffer containing
past values of expression expr. Without further information, the
complete time history of the delayed signals needs to be stored, because
the delay time may change during simulation. To avoid excessive storage
requirements and to enhance efficiency, the maximum allowed delay time
has to be given via</em> <code class="docutils literal highlight highlight-modelica"><span class="n">delayMax</span></code><em>.</em></p>
<p><em>This gives an upper bound on the values of the delayed signals which
have to be stored. For real-time simulation where fixed step size
integrators are used, this information is sufficient to allocate the
necessary storage for the internal buffer before the simulation starts.
For variable step size integrators, the buffer size is dynamic during
integration. In principle, a</em> delay <em>operator could break algebraic
loops. For simplicity, this is not supported because the minimum delay
time has to be give as additional argument to be fixed at compile time.
Furthermore, the maximum step size of the integrator is limited by this
minimum delay time in order to avoid extrapolation in the delay
buffer</em>.]</p>
</div>
<div class="section" id="spatialdistribution">
<span id="operator-spatialdistribution"></span><h4>spatialDistribution<a class="headerlink" href="#spatialdistribution" title="Permalink to this headline">¶</a></h4>
<p>[<em>Many applications involve the modelling of variable-speed transport of
properties. One option to model this infinite-dimensional system is to
approximate it by an ODE, but this requires a large number of state
variables and might introduce either numerical diffusion or numerical
oscillations. Another option is to use a built-in operator that keeps
track of the spatial distribution of z(y, t), by suitable sampling,
interpolation, and shifting of the stored distribution. In this case,
the internal state of the operator is hidden from the ODE solver.</em>]</p>
<p>The spatialDistribution() operator allows to approximate efficiently the
solution of the infinite-dimensional problem:</p>
<div class="math">
<p><img src="_images/math/56cd28479e0d5e1fe589e48e8c618c61b9edda8b.svg" alt="{\partial z(y,t) \over \partial t} + v(t) {\partial z(y,t) \over \partial y} = 0.0"/></p>
</div><div class="math">
<p><img src="_images/math/d28b50dbd653dff1ff433608c56b34ae7f4b063e.svg" alt="z(0.0, t) = in_0(t) \text{ if } v &gt;= 0"/></p>
</div><div class="math">
<p><img src="_images/math/0528e5aa2cca55ad7f191de950e111a7a1cfd63f.svg" alt="z(1.0, t) = in_1(t) \text{ if } v &lt; 0"/></p>
</div><p>where <em>z(y, t)</em> is the transported quantity, <em>y</em> is the normalized
spatial coordinate (0.0 ≤ <em>y</em> ≤ 1.0), <em>t</em> is the time,
<em>v</em>(<em>t</em>)=<strong>der</strong>(<em>x</em>) is the normalized transport velocity and the
boundary conditions are set at either <em>y</em> = 0.0 or <em>y</em> = 1.0, depending
on the sign of the velocity. The calling syntax is:</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="p">(</span><span class="n">out0</span><span class="p">,</span> <span class="n">out1</span><span class="p">)</span> <span class="o">=</span> <span class="nb">spatialDistribution</span><span class="p">(</span><span class="n">in0</span><span class="p">,</span> <span class="n">in1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">positiveVelocity</span><span class="p">,</span>
  <span class="n">initialPoints</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">},</span>
  <span class="n">initialValues</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">});</span>
</pre></div>
</div>
<p>where in0, in1, out0, out1, x, v are all subtypes of Real,
positiveVelocity is a Boolean, initialPoints and initialValues are
arrays of subtypes of Real of equal size, containing the y coordinates
and the <em>z</em> values of a finite set of points describing the initial
distribution of <em>z</em>(<em>y, t0</em>). The out0 and out1 are given by the
solutions at <em>z(0.0, t)</em> and <em>z(1.0, t)</em>; and in0 and in1 are the
boundary conditions at <em>z(0.0, t)</em> and <em>z(1.0, t)</em> (at each point in
time only one of in0 and in1 is used). Elements in the initialPoints
array must be sorted in non-descending order. The operator can not be
vectorized according to the vectorization rules described in section
12.4.6. The operator can be vectorized only with respect to the
arguments in0 and in1 (which must have the same size), returning
vectorized outputs out0 and out1 of the same size; the arguments
initialPoints and initialValues are vectorized accordingly.</p>
<p>The solution, z(..), can be described in terms of characteristics:</p>
<p>= <em>z</em>(<em>y</em>, <em>t</em>), for all, as long as staying inside the domain.</p>
<p>This allows to directly compute the solution based on interpolating the
boundary conditions.</p>
<p>The <code class="docutils literal highlight highlight-modelica"><span class="nb">spatialDistribution</span></code> operator can be described in terms of the
pseudo-code given as a block:</p>
<div class="literal-block-wrapper container" id="pseudo-code-for-spatialdistribution-in-terms-of-a-block">
<div class="code-block-caption"><span class="caption-number">Listing 1 </span><span class="caption-text">Pseudo-code for spatialDistribution in terms of a block.</span><a class="headerlink" href="#pseudo-code-for-spatialdistribution-in-terms-of-a-block" title="Permalink to this code">¶</a></div>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">block</span> <span class="nc">spatialDistribution</span>
  <span class="kr">input</span> <span class="nb">Real</span> <span class="n">in0</span><span class="p">;</span>
  <span class="kr">input</span> <span class="nb">Real</span> <span class="n">in1</span><span class="p">;</span>
  <span class="kr">input</span> <span class="nb">Real</span> <span class="n">x</span><span class="p">;</span>
  <span class="kr">input</span> <span class="nb">Boolean</span> <span class="n">positiveVelocity</span><span class="p">;</span>
  <span class="kr">parameter</span> <span class="nb">Real</span> <span class="n">initialPoints</span><span class="p">(</span><span class="kr">each</span> <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kr">each</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="o">:</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">};</span>
  <span class="kr">parameter</span> <span class="nb">Real</span> <span class="n">initialValues</span><span class="p">[</span><span class="o">:</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">};</span>
  <span class="kr">output</span> <span class="nb">Real</span> <span class="n">out0</span><span class="p">;</span>
  <span class="kr">output</span> <span class="nb">Real</span> <span class="n">out1</span><span class="p">;</span>
  <span class="kr">protected</span>
  <span class="nb">Real</span> <span class="n">points</span><span class="p">[</span><span class="o">:</span><span class="p">];</span>
  <span class="nb">Real</span> <span class="n">values</span><span class="p">[</span><span class="o">:</span><span class="p">];</span>
  <span class="nb">Real</span> <span class="n">x0</span><span class="p">;</span>
  <span class="nb">Integer</span> <span class="n">m</span><span class="p">;</span>
<span class="kr">algorithm</span>
  <span class="kr">if</span> <span class="n">positiveVelocity</span> <span class="kr">then</span>
    <span class="n">out1</span><span class="o">:=</span><span class="n">interpolate</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">));</span>
    <span class="n">out0</span><span class="o">:=</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// similar to in0 but avoiding algebraic loop</span>
  <span class="kr">else</span>
    <span class="n">out0</span><span class="o">:=</span><span class="n">interpolate</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">));</span>
    <span class="n">out1</span><span class="o">:=</span><span class="n">values</span><span class="p">[</span><span class="kr">end</span><span class="p">];</span> <span class="c1">// similar to in1 but avoiding algebraic loop</span>
  <span class="kr">end</span> <span class="kr">if</span><span class="p">;</span>
  <span class="kr">when</span> <span class="cm">/* acceptedStep */</span> <span class="kr">then</span>
    <span class="kr">if</span> <span class="n">x</span><span class="o">&gt;</span><span class="n">x0</span> <span class="kr">then</span>
      <span class="n">m</span><span class="o">:=</span><span class="nb">size</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
      <span class="kr">while</span> <span class="p">(</span><span class="kr">if</span> <span class="n">m</span><span class="o">&gt;</span><span class="mi">0</span> <span class="kr">then</span> <span class="n">points</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">&gt;=</span><span class="mi">1</span> <span class="kr">else</span> <span class="kc">false</span><span class="p">)</span> <span class="kr">then</span>
        <span class="n">m</span><span class="o">:=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="kr">end</span> <span class="kr">while</span><span class="p">;</span>
      <span class="n">values</span><span class="o">:=</span><span class="nb">cat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="n">in0</span><span class="p">},</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="n">m</span><span class="p">],</span> <span class="p">{</span><span class="n">interpolate</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">))}</span> <span class="p">);</span>
      <span class="n">points</span><span class="o">:=</span><span class="nb">cat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="n">m</span><span class="p">]</span> <span class="o">.+</span> <span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="p">),</span> <span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="p">);</span>
    <span class="kr">elseif</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">x0</span> <span class="kr">then</span>
      <span class="n">m</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span>
      <span class="kr">while</span> <span class="p">(</span><span class="kr">if</span> <span class="n">m</span><span class="o">&lt;</span><span class="nb">size</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="kr">then</span> <span class="n">points</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="kr">else</span> <span class="kc">false</span><span class="p">)</span> <span class="kr">then</span>
        <span class="n">m</span><span class="o">:=</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
      <span class="kr">end</span> <span class="kr">while</span><span class="p">;</span>
      <span class="n">values</span><span class="o">:=</span><span class="nb">cat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="n">interpolate</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="mi">0</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">))},</span><span class="n">values</span><span class="p">[</span><span class="n">m</span><span class="o">:</span><span class="kr">end</span><span class="p">],{</span><span class="n">in1</span><span class="p">});</span>
      <span class="n">points</span><span class="o">:=</span><span class="nb">cat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">points</span><span class="p">[</span><span class="n">m</span><span class="o">:</span><span class="kr">end</span><span class="p">]</span> <span class="o">.+</span> <span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="p">),</span> <span class="p">{</span><span class="mi">1</span><span class="p">});</span>
    <span class="kr">end</span> <span class="kr">if</span><span class="p">;</span>
    <span class="n">x0</span><span class="o">:=</span><span class="n">x</span><span class="p">;</span>
  <span class="kr">end</span> <span class="kr">when</span><span class="p">;</span>
<span class="kr">initial</span> <span class="kr">algorithm</span>
  <span class="n">x0</span><span class="o">:=</span><span class="n">x</span><span class="p">;</span>
  <span class="n">points</span><span class="o">:=</span><span class="n">initialPoints</span><span class="p">;</span>
  <span class="n">values</span><span class="o">:=</span><span class="n">initialValues</span><span class="p">;</span>
<span class="kr">end</span> <span class="nc">spatialDistribution</span><span class="p">;</span>
</pre></div>
</div>
</div>
<p>[<em>The infinite-dimensional problem stated above can then be formulated
in the following way:</em></p>
<p><em>Events are generated at the exact instants when the velocity changes
sign – if this is not needed, noEvent() can be used to suppress
event generation.</em></p>
<p><em>If the velocity is known to be always positive, then out0 can be
omitted, e.g.:</em></p>
<p><em>Technically relevant use cases for the use of the</em>
spatialDistribution<em>() operator are modeling of electrical
transmission lines, pipelines and pipeline networks for gas, water and
district heating, sprinkler systems, impulse propagation in elongated
bodies, conveyor belts, and hydraulic systems. Vectorization is needed
for pipelines where more than one quantity is transported with velocity
v in the example above.</em>]</p>
</div>
<div class="section" id="cardinality-deprecated">
<span id="operator-cardinality"></span><h4>cardinality (deprecated)<a class="headerlink" href="#cardinality-deprecated" title="Permalink to this headline">¶</a></h4>
<p>[<em>The cardinality operator is deprecated for the following reasons and
will be removed in a future release:</em></p>
<ul class="simple">
<li><em>Reflective operator may make early type checking more difficult.</em></li>
<li><em>Almost always abused in strange ways</em></li>
<li><em>Not used for Bond graphs even though it was originally introduced
for that purpose.</em></li>
</ul>
<p>]</p>
<p>[<em>The</em> cardinality() <em>operator allows the definition of connection
dependent equations in a model, for example</em>:</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">connector</span> <span class="nc">Pin</span>
  <span class="nb">Real</span> <span class="n">v</span><span class="p">;</span>
  <span class="kr">flow</span> <span class="nb">Real</span> <span class="n">i</span><span class="p">;</span>
<span class="kr">end</span> <span class="nc">Pin</span><span class="p">;</span>

<span class="kr">model</span> <span class="nc">Resistor</span>
  <span class="n">Pin</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
<span class="kr">equation</span>
  <span class="nb">assert</span><span class="p">(</span><span class="nb">cardinality</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">cardinality</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Connectors p and n of Resistor must be connected&quot;</span><span class="p">);</span>
  <span class="c1">// Equations of resistor ...</span>
<span class="kr">end</span> <span class="nc">Resistor</span><span class="p">;</span>
</pre></div>
</div>
<p>]</p>
<p>The cardinality is counted after removing conditional components. and
may not be applied to expandable connectors, elements in expandable
connectors, or to arrays of connectors (but can be applied to the scalar
elements of array of connectors). The cardinality operator should only
be used in the condition of assert and if-statements – that do not
contain connect (and similar operators – see section 8.3.3).</p>
</div>
<div class="section" id="homotopy">
<span id="operator-homotopy"></span><h4>homotopy<a class="headerlink" href="#homotopy" title="Permalink to this headline">¶</a></h4>
<p><em>[During the initialization phase of a dynamic simulation problem, it
often happens that large nonlinear systems of equations must be solved
by means of an iterative solver. The convergence of such solvers
critically depends on the choice of initial guesses for the unknown
variables. The process can be made more robust by providing an
alternative, simplified version of the model, such that convergence is
possible even without accurate initial guess values, and then by
continuously transforming the simplified model into the actual model.
This transformation can be formulated using expressions of this kind:</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="n">lambda</span><span class="o">*</span><span class="n">actual</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">lambda</span><span class="p">)</span><span class="o">*</span><span class="n">simplified</span>
</pre></div>
</div>
<p><em>in the formulation of the system equations, and is usually called a
homotopy transformation. If the simplified expression is chosen
carefully, the solution of the problem changes continuously with lambda,
so by taking small enough steps it is possible to eventually obtain the
solution of the actual problem.</em></p>
<p><em>The operator can be called with ordered arguments or preferably with
named arguments for improved readability.</em></p>
<p><em>It is recommended to perform (conceptually) one homotopy iteration over
the whole model, and not several homotopy iterations over the respective
non-linear algebraic equation systems. The reason is that the following
structure can be present:</em></p>
<blockquote>
<div><div class="line-block">
<div class="line"><strong>w</strong> = <strong>f</strong><sub>1</sub>(<strong>x</strong>) // has homotopy operator</div>
<div class="line"><strong>0</strong> = <strong>f</strong><sub>2</sub>(der(<strong>x</strong>), <strong>x</strong>, <strong>z</strong>, <strong>w</strong>)</div>
</div>
</div></blockquote>
<p><em>Here, a non-linear equation system</em> <strong>f</strong><sub>2</sub> <em>is present. The
homotopy operator is, however used on a variable that is an “input” to
the non-linear algebraic equation system, and modifies the
characteristics of the non-linear algebraic equation system. The only
useful way is to perform the homotopy iteration over</em> <strong>f</strong><sub>1</sub>
<em>and</em> <strong>f</strong><sub>2</sub> <em>together.</em></p>
<p><em>The suggested approach is “conceptual”, because more efficient
implementations are possible, e.g. by determining the smallest iteration
loop, that contains the equations of the first BLT block in which a
homotopy operator is present and all equations up to the last BLT block
that describes a non-linear algebraic equation system.</em></p>
<p><em>A trivial implementation of the homotopy operator is obtained by
defining the following function in the global scope:</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">function</span> <span class="nc">homotopy</span>
  <span class="kr">input</span> <span class="nb">Real</span> <span class="n">actual</span><span class="p">;</span>
  <span class="kr">input</span> <span class="nb">Real</span> <span class="n">simplified</span><span class="p">;</span>
  <span class="kr">output</span> <span class="nb">Real</span> <span class="n">y</span><span class="p">;</span>
<span class="kr">algorithm</span>
  <span class="n">y</span> <span class="o">:=</span> <span class="n">actual</span><span class="p">;</span>
<span class="kr">annotation</span><span class="p">(</span><span class="n">Inline</span> <span class="o">=</span> <span class="kc">true</span><span class="p">);</span>
<span class="kr">end</span> <span class="nc">homotopy</span><span class="p">;</span>
</pre></div>
</div>
<p><em>Example 1:</em></p>
<p><em>In electrical systems it is often difficult to solve non-linear
algebraic equations if switches are part of the algebraic loop. An
idealized diode model might be implemented in the following way, by
starting with a “flat” diode characteristic and then move with the
homotopy operator to the desired “steep” characteristic:</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">model</span> <span class="nc">IdealDiode</span>
  <span class="c1">// ...</span>
  <span class="kr">parameter</span> <span class="nb">Real</span> <span class="n">Goff</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">;</span>
  <span class="kr">protected</span>
  <span class="nb">Real</span> <span class="n">Goff_flat</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">Goff</span><span class="p">);</span>
  <span class="nb">Real</span> <span class="n">Goff2</span><span class="p">;</span>
<span class="kr">equation</span>
  <span class="n">off</span> <span class="o">=</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Goff2</span> <span class="o">=</span> <span class="nb">homotopy</span><span class="p">(</span><span class="n">actual</span><span class="o">=</span><span class="n">Goff</span><span class="p">,</span> <span class="n">simplified</span><span class="o">=</span><span class="n">Goff_flat</span><span class="p">);</span>
  <span class="n">u</span> <span class="o">=</span> <span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="kr">if</span> <span class="n">off</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="n">Ron2</span><span class="p">)</span> <span class="o">+</span> <span class="n">Vknee</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">s</span><span class="o">*</span><span class="p">(</span><span class="kr">if</span> <span class="n">off</span> <span class="kr">then</span> <span class="n">Goff2</span> <span class="kr">else</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="n">Goff2</span><span class="o">*</span><span class="n">Vknee</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="kr">end</span> <span class="nc">IdealDiode</span><span class="p">;</span>
</pre></div>
</div>
<p><em>Example 2:</em></p>
<p><em>In electrical systems it is often useful that all voltage sources start
with zero voltage and all current sources with zero current, since
steady state initialization with zero sources can be easily obtained. A
typical voltage source would then be defined as:</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">model</span> <span class="nc">ConstantVoltageSource</span>
  <span class="kr">extends</span> <span class="n">Modelica</span><span class="o">.</span><span class="n">Electrical</span><span class="o">.</span><span class="n">Analog</span><span class="o">.</span><span class="n">Interfaces</span><span class="o">.</span><span class="n">OnePort</span><span class="p">;</span>
  <span class="kr">parameter</span> <span class="n">Modelica</span><span class="o">.</span><span class="n">SIunits</span><span class="o">.</span><span class="n">Voltage</span> <span class="n">V</span><span class="p">;</span>
<span class="kr">equation</span>
  <span class="n">v</span> <span class="o">=</span> <span class="nb">homotopy</span><span class="p">(</span><span class="n">actual</span><span class="o">=</span><span class="n">V</span><span class="p">,</span> <span class="n">simplified</span><span class="o">=</span><span class="mf">0.0</span><span class="p">);</span>
<span class="kr">end</span> <span class="nc">ConstantVoltageSource</span><span class="p">;</span>
</pre></div>
</div>
<p><em>Example 3:</em></p>
<p><em>In fluid system modelling, the pressure/flowrate relationships are
highly nonlinear due to the quadratic terms and due to the dependency on
fluid properties. A simplified linear model, tuned on the nominal
operating point, can be used to make the overall model less nonlinear
and thus easier to solve without accurate start values. Named arguments
are used here in order to further improve the readability.</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">model</span> <span class="nc">PressureLoss</span>
  <span class="kr">import</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">Modelica</span><span class="o">.</span><span class="n">SIunits</span><span class="p">;</span>
  <span class="c1">// ...</span>
  <span class="kr">parameter</span> <span class="n">SI</span><span class="o">.</span><span class="n">MassFlowRate</span> <span class="n">m_flow_nominal</span> <span class="s2">&quot;Nominal mass flow rate&quot;</span><span class="p">;</span>
  <span class="kr">parameter</span> <span class="n">SI</span><span class="o">.</span><span class="n">Pressure</span> <span class="n">dp_nominal</span> <span class="s2">&quot;Nominal pressure drop&quot;</span><span class="p">;</span>
  <span class="n">SI</span><span class="o">.</span><span class="n">Density</span> <span class="n">rho</span> <span class="s2">&quot;Upstream density&quot;</span><span class="p">;</span>
  <span class="n">SI</span><span class="o">.</span><span class="n">DynamicViscosity</span> <span class="n">lambda</span> <span class="s2">&quot;Upstream viscosity&quot;</span><span class="p">;</span>
<span class="kr">equation</span>
  <span class="c1">// ...</span>
  <span class="n">m_flow</span> <span class="o">=</span> <span class="nb">homotopy</span><span class="p">(</span><span class="n">actual</span> <span class="o">=</span> <span class="n">turbulentFlow_dp</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">lambda</span><span class="p">),</span>
  <span class="n">simplified</span> <span class="o">=</span> <span class="n">dp</span><span class="o">/</span><span class="n">dp_nominal</span><span class="o">*</span><span class="n">m_flow_nominal</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="kr">end</span> <span class="nc">PressureLoss</span><span class="p">;</span>
</pre></div>
</div>
<p><em>Example 4:</em></p>
<p><em>Note that the homotopy operator **shall not*</em> be used to combine
unrelated expressions, since this can generate singular systems from
combining two well-defined systems.*</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">model</span> <span class="nc">DoNotUse</span>
  <span class="nb">Real</span> <span class="n">x</span><span class="p">;</span>
  <span class="kr">parameter</span> <span class="nb">Real</span> <span class="n">x0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">equation</span>
  <span class="kr">der</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">;</span>
<span class="kr">initial</span> <span class="kr">equation</span>
  <span class="mi">0</span> <span class="o">=</span> <span class="nb">homotopy</span><span class="p">(</span><span class="kr">der</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">);</span>
<span class="kr">end</span> <span class="nc">DoNotUse</span><span class="p">;</span>
</pre></div>
</div>
<p><em>The initial equation is expanded into</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="mi">0</span> <span class="o">=</span> <span class="n">lambda</span><span class="o">*</span><span class="kr">der</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">lambda</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span>
</pre></div>
</div>
<p><em>and you can solve the two equations to give</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">lambda</span><span class="o">+</span><span class="p">(</span><span class="n">lambda</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">x0</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">lambda</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><em>which has the correct value of x0 at lambda = 0 and of 1 at lambda = 1,
but unfortunately has a singularity at lambda = 0.5.</em></p>
<p><em>]</em></p>
</div>
<div class="section" id="semilinear">
<span id="operator-semilinear"></span><h4>semiLinear<a class="headerlink" href="#semilinear" title="Permalink to this headline">¶</a></h4>
<p>(See definition of <a class="reference internal" href="#operator-def-semilinear"><span>semiLinear</span></a>). In some situations,
equations with the semiLinear() function become underdetermined if the
first argument (x) becomes zero, i.e., there are an infinite number of
solutions. It is recommended that the following rules are used to
transform the equations during the translation phase in order to select
one meaningful solution in such cases:</p>
<p><strong>Rule 1</strong>: The equations</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="n">y</span> <span class="o">=</span> <span class="nb">semiLinear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">semiLinear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">semiLinear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="c1">// ...</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">semiLinear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">sb</span><span class="p">);</span>
<span class="c1">// ...</span>
</pre></div>
</div>
<p>may be replaced by</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="kr">then</span> <span class="n">sa</span> <span class="kr">else</span> <span class="n">sb</span>
<span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">s</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="c1">// ...</span>
<span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">semiLinear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>Rule 2</strong>: The equations</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">semiLinear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
</pre></div>
</div>
<p>may be replaced by</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">sa</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
</pre></div>
</div>
<p>[<em>For symbolic transformations, the following property is useful (this
follows from the definition):</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="nb">semiLinear</span><span class="p">(</span><span class="n">m_flow</span><span class="p">,</span> <span class="n">port_h</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
</pre></div>
</div>
<p><em>is identical to :</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="o">-</span><span class="nb">semiLinear</span><span class="p">(</span><span class="o">-</span><span class="n">m_flow</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">port_h</span><span class="p">);</span>
</pre></div>
</div>
<p><em>The</em> <code class="docutils literal highlight highlight-modelica"><span class="nb">semiLinear</span></code> <em>function is designed to handle reversing flow in fluid
systems, such as</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="n">H_flow</span><span class="o">=</span><span class="nb">semiLinear</span><span class="p">(</span><span class="n">m_flow</span><span class="p">,</span> <span class="n">port</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
</pre></div>
</div>
<p><em>i.e., the enthalpy flow rate</em> <code class="docutils literal highlight highlight-modelica"><span class="n">H_flow</span></code> <em>is computed from the mass flow
rate</em> <code class="docutils literal highlight highlight-modelica"><span class="n">m_flow</span></code> <em>and the upstream specific enthalpy depending on the flow
direction.</em></p>
<p>]</p>
</div>
<div class="section" id="getinstancename">
<span id="operator-instancename"></span><h4>getInstanceName<a class="headerlink" href="#getinstancename" title="Permalink to this headline">¶</a></h4>
<p>Returns a string with the name of the model/block that is simulated,
appended with the fully qualified name of the instance in which this
function is called.</p>
<p>[<em>Example:</em></p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">package</span> <span class="nc">MyLib</span>
  <span class="kr">model</span> <span class="nc">Vehicle</span>
  <span class="n">Engine</span> <span class="n">engine</span><span class="p">;</span>
  <span class="o">...</span>
  <span class="kr">end</span> <span class="nc">Vehicle</span><span class="p">;</span>

  <span class="kr">model</span> <span class="nc">Engine</span>
  <span class="n">Controller</span> <span class="n">controller</span><span class="p">;</span>
  <span class="o">...</span>
  <span class="kr">end</span> <span class="nc">Engine</span><span class="p">;</span>

  <span class="kr">model</span> <span class="nc">Controller</span>
  <span class="kr">equation</span>
  <span class="n">Modelica</span><span class="o">.</span><span class="n">Utilities</span><span class="o">.</span><span class="n">Streams</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s2">&quot;Info from: &quot;</span> <span class="o">+</span> <span class="nb">getInstanceName</span><span class="p">());</span>
  <span class="kr">end</span> <span class="nc">Controller</span><span class="p">;</span>

<span class="kr">end</span> <span class="nc">MyLib</span><span class="p">;</span>
</pre></div>
</div>
<p><em>If MyLib.Vehicle is simulated, the call of getInstanceName()
returns:&#8221;Vehicle.engine.controller&#8221;</em></p>
<p>]</p>
<p>If this function is not called inside a model or block (e.g. the
function is called in a function or in a constant of a package), the
return value is not specified.</p>
<p>[<em>The simulation result should not depend on the return value of this
function.</em> ]</p>
</div>
</div>
<div class="section" id="event-related-operators-with-function-syntax">
<span id="event-related-operators"></span><h3>Event-Related Operators with Function Syntax<a class="headerlink" href="#event-related-operators-with-function-syntax" title="Permalink to this headline">¶</a></h3>
<p>The following event-related operators with function syntax are
supported. The operators noEvent, pre, edge, and change, are
vectorizable according to Section 12.4.6</p>
<dl class="docutils">
<dt><code class="docutils literal highlight highlight-modelica"><span class="kr">initial</span><span class="p">()</span></code></dt>
<dd>Returns true during the initialization phase and false otherwise [<em>thereby triggering a time event at the beginning of a simulation</em>].</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">terminal</span><span class="p">()</span></code></dt>
<dd>Returns true at the end of a successful analysis [<em>thereby ensuring an event at the end of successful simulation</em>].</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">noEvent</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span></code></dt>
<dd>Real elementary relations within expr are taken literally, i.e., no state or time event is triggered. See also Section <a class="reference internal" href="#noevent-smooth"><span>noEvent and smooth</span></a> and Section 8.5.</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">smooth</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span></code></dt>
<dd>If p&gt;=0 smooth(p,expr) returns expr and states that expr is p times
continuously differentiable, i.e.: expr is continuous in all real
variables appearing in the expression and all partial derivatives with
respect to all appearing real variables exist and are continuous up to
order p.
The argument p should be a scalar integer parameter expression.
The only allowed types for expr in smooth are: real expressions, arrays
of allowed expressions, and records containing only components of
allowed expressions. See also Section <a class="reference internal" href="#noevent-smooth"><span>noEvent and smooth</span></a>.</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">sample</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="nb">interval</span><span class="p">)</span></code></dt>
<dd>Returns true and triggers time events at time instants
<code class="docutils literal highlight highlight-modelica"><span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="nb">interval</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span></code>.
During continuous integration the operator returns always false.
The starting time start and the sample interval interval need to be
parameter expressions and need to be a subtype of Real or Integer.                                                                                                                                                                                                                                                                                                                                                                                                                                           |</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">pre</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></code></dt>
<dd><p class="first">Returns the &#8220;left limit&#8221; y(t<sup>pre</sup>) of variable y(t) at a time
instant t. At an event instant, y(t<sup>pre</sup>) is the value of y
after the last event iteration at time instant t (see comment below).
The pre() operator can be applied if the following three conditions
are fulfilled simultaneously:</p>
<ol class="loweralpha simple">
<li>variable y is either a subtype of a simple type or is a record component</li>
<li>y is a discrete-time expression</li>
<li>the operator is <em>not</em> applied in a function class.</li>
</ol>
<p class="last">[<em>Note: This can be applied to continuous-time variables in when-clauses,
see Section :ref:`discrete-time-expressions` for the definition of discrete-time expression.</em>]
The first value of pre(y) is determined in the initialization phase. See also Section <span class="xref std std-ref">operator-pre</span>.</p>
</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">edge</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></code></dt>
<dd>Is expanded into <code class="docutils literal highlight highlight-modelica"><span class="p">(</span><span class="n">b</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">pre</span><span class="p">(</span><span class="n">b</span><span class="p">))</span></code> for Boolean variable <code class="docutils literal highlight highlight-modelica"><span class="n">b</span></code>.
The same restrictions as for the <code class="docutils literal highlight highlight-modelica"><span class="nb">pre</span><span class="p">()</span></code> operator apply (e.g. not to be used in function classes).</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">change</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></code></dt>
<dd>Is expanded into <code class="docutils literal highlight highlight-modelica"><span class="p">(</span><span class="n">v</span><span class="o">&lt;&gt;</span><span class="nb">pre</span><span class="p">(</span><span class="n">v</span><span class="p">))</span></code>.
The same restrictions as for the <code class="docutils literal highlight highlight-modelica"><span class="nb">pre</span><span class="p">()</span></code> operator apply.</dd>
<dt><code class="docutils literal highlight highlight-modelica"><span class="nb">reinit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span></code></dt>
<dd>In the body of a when clause, reinitializes <code class="docutils literal highlight highlight-modelica"><span class="n">x</span></code> with <code class="docutils literal highlight highlight-modelica"><span class="n">expr</span></code> at an event instant.
<code class="docutils literal highlight highlight-modelica"><span class="n">x</span></code> is a Real variable (or an array of Real variables) that is
implicitly defined to have <code class="docutils literal highlight highlight-modelica"><span class="nb">StateSelect</span><span class="o">.</span><span class="n">always</span></code> [<em>so must be selected as a state, and it is an error, if this is not possible</em>].
expr needs to be type-compatible with x.
The <code class="docutils literal highlight highlight-modelica"><span class="nb">reinit</span></code> operator can only be applied once for the same variable
- either as an individual variable or as part of an array of variables.
It can only be applied in the body of a when clause in an equation section.
See also Section <span class="xref std std-ref">TODO: 8.3.6</span>.</dd>
</dl>
<p>A few of these operators are described in more detail in the following.</p>
<div class="section" id="pre">
<h4>pre<a class="headerlink" href="#pre" title="Permalink to this headline">¶</a></h4>
<p>A new event is triggered if at least for one variable <code class="docutils literal highlight highlight-modelica"><span class="n">v</span></code> <code class="docutils literal highlight highlight-modelica"><span class="nb">pre</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;&gt;</span> <span class="n">v</span></code>
after the active model equations are evaluated at an event instant. In
this case the model is at once reevaluated. This evaluation sequence is
called “<em>event iteration</em>”. The integration is restarted, if for all
v used in pre-operators the following condition holds: <code class="docutils literal highlight highlight-modelica"><span class="nb">pre</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">v</span></code>.</p>
<p>[<em>If</em> <code class="docutils literal highlight highlight-modelica"><span class="n">v</span></code> <em>and</em> <code class="docutils literal highlight highlight-modelica"><span class="nb">pre</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></code> <em>are only used in when-clauses, the translator
might mask event iteration for variable v since v cannot change during
event iteration. It is a “quality of implementation” to find the minimal
loops for event iteration, i.e., not all parts of the model need to be
reevaluated.</em></p>
<p><em>The language allows mixed algebraic systems of equations where the
unknown variables are of type Real, Integer, Boolean, or an enumeration.
These systems of equations can be solved by a global fix point iteration
scheme, similarly to the event iteration, by fixing the Boolean,
Integer, and/or enumeration unknowns during one iteration. Again, it is
a quality of implementation to solve these systems more efficiently,
e.g., by applying the fix point iteration scheme to a subset of the
model equations.</em>]</p>
</div>
<div class="section" id="noevent-and-smooth">
<span id="noevent-smooth"></span><h4>noEvent and smooth<a class="headerlink" href="#noevent-and-smooth" title="Permalink to this headline">¶</a></h4>
<p>The noEvent operator implies that real elementary expressions are taken
literally instead of generating crossing functions, Section <span class="xref std std-ref">TODO: 8.5</span>.
The smooth operator should be used instead of noEvent, in order to avoid
events for efficiency reasons. A tool is free to not generate events for
expressions inside smooth. However, smooth does not guarantee that no
events will be generated, and thus it can be necessary to use noEvent
inside smooth. [<em>Note that</em> smooth <em>does not guarantee a smooth output
if any of the occurring variables change discontinuously.</em>]</p>
<p>[<em>Example</em>:</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="nb">Real</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">;</span>
<span class="kr">parameter</span> <span class="nb">Real</span> <span class="n">p</span><span class="p">;</span>
<span class="kr">equation</span>
<span class="n">x</span> <span class="o">=</span> <span class="kr">if</span> <span class="nb">time</span><span class="o">&lt;</span><span class="mi">1</span> <span class="kr">then</span> <span class="mi">2</span> <span class="kr">else</span> <span class="nb">time</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
<span class="n">z</span> <span class="o">=</span> <span class="nb">smooth</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kr">if</span> <span class="nb">time</span><span class="o">&lt;</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="nb">time</span><span class="p">);</span>
<span class="n">y</span> <span class="o">=</span> <span class="nb">smooth</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">noEvent</span><span class="p">(</span><span class="kr">if</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span> <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> <span class="nb">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">));</span>
<span class="c1">// noEvent is necessary.</span>
</pre></div>
</div>
<p>]</p>
</div>
</div>
</div>
<div class="section" id="variability-of-expressions">
<h2>Variability of Expressions<a class="headerlink" href="#variability-of-expressions" title="Permalink to this headline">¶</a></h2>
<p>The concept of variability of an expression indicates to what extent the
expression can vary over time. See also Section <span class="xref std std-ref">TODO: 4.4.4</span>
regarding the concept of variability.
There are four levels of variability of expressions, starting from the
least variable:</p>
<ul class="simple">
<li>constant variability</li>
<li>parameter variability</li>
<li>discrete-time variability</li>
<li>continuous-time variability</li>
</ul>
<p>For an assignment <code class="docutils literal highlight highlight-modelica"><span class="n">v</span><span class="o">:=</span><span class="n">expr</span></code> or binding equation <code class="docutils literal highlight highlight-modelica"><span class="n">v</span><span class="o">=</span><span class="n">expr</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="n">v</span></code> must be declared
to be at least as variable as <code class="docutils literal highlight highlight-modelica"><span class="n">expr</span></code>.</p>
<ul class="simple">
<li>The right-hand side expression in a binding equation [<em>that is</em>,
<code class="docutils literal highlight highlight-modelica"><span class="n">expr</span></code> ] of a parameter component and of the base type attributes
[<em>such as</em> <code class="docutils literal highlight highlight-modelica"><span class="n">start</span></code>] needs to be a parameter or constant expression.</li>
<li>If <code class="docutils literal highlight highlight-modelica"><span class="n">v</span></code> is a discrete-time component then <code class="docutils literal highlight highlight-modelica"><span class="n">expr</span></code> needs to be a
discrete-time expression.</li>
</ul>
<div class="section" id="constant-expressions">
<h3>Constant Expressions<a class="headerlink" href="#constant-expressions" title="Permalink to this headline">¶</a></h3>
<p>Constant expressions are:</p>
<ul class="simple">
<li>Real, Integer, Boolean, String, and enumeration literals.</li>
<li>Variables declared as constant.</li>
<li>Except for the special built-in operators initial, terminal, der,
edge, change, sample, and pre, a function or operator with constant
subexpressions as argument (and no parameters defined in the
function) is a constant expression.</li>
</ul>
<p>Components declared as constant shall have an associated declaration
equation with a constant expression, if the constant is directly in the
simulation model, or used in the simulation model. The value of a
constant can be modified after it has been given a value, unless the
constant is declared final or modified with a final modifier. A constant
without an associated declaration equation can be given one by using a
modifier.</p>
</div>
<div class="section" id="parameter-expressions">
<h3>Parameter Expressions<a class="headerlink" href="#parameter-expressions" title="Permalink to this headline">¶</a></h3>
<p>Parameter expressions are:</p>
<ul class="simple">
<li>Constant expressions.</li>
<li>Variables declared as parameter.</li>
<li>Except for the special built-in operators initial, terminal, der,
edge, change, sample, and pre, a function or operator with parameter
subexpressions is a parameter expression.</li>
</ul>
</div>
<div class="section" id="discrete-time-expressions">
<span id="id3"></span><h3>Discrete-Time Expressions<a class="headerlink" href="#discrete-time-expressions" title="Permalink to this headline">¶</a></h3>
<p>Discrete-time expressions are:</p>
<ul class="simple">
<li>Parameter expressions.</li>
<li>Discrete-time variables, i.e., Integer, Boolean, String variables and
enumeration variables, as well as Real variables assigned in
when-clauses</li>
<li>Function calls where all input arguments of the function are
discrete-time expressions.</li>
<li>Expressions where all the subexpressions are discrete-time
expressions.</li>
<li>Expressions in the body of a when-clause, initial equation, or
initial algorithm.</li>
<li>Unless inside noEvent: Ordered relations (<code class="docutils literal highlight highlight-modelica"><span class="o">&gt;</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="o">&lt;</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="o">&gt;=</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="o">&lt;=</span></code>) if at least one
operand is a subtype of Real (i.e. Real elementary relations, see
Section <a class="reference internal" href="#eq-relational-logic-operators"><span>Equality, Relational, and Logical Operators</span></a>) and the functions <code class="docutils literal highlight highlight-modelica"><span class="nb">ceil</span></code>,
<code class="docutils literal highlight highlight-modelica"><span class="nb">floor</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="nb">div</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="nb">mod</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="nb">rem</span></code>.
These will generate events if at least one subexpression is not a
discrete-time expression. [<em>In other words, relations inside</em> <code class="docutils literal highlight highlight-modelica"><span class="nb">noEvent</span><span class="p">()</span></code> <em>,
such as</em> <code class="docutils literal highlight highlight-modelica"><span class="nb">noEvent</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span></code><em>, are not discrete-time expressions</em>].</li>
<li>The functions <code class="docutils literal highlight highlight-modelica"><span class="nb">pre</span></code>, <code class="docutils literal highlight highlight-modelica"><span class="nb">edge</span></code>, and <code class="docutils literal highlight highlight-modelica"><span class="nb">change</span></code> result in discrete-time
expressions.</li>
<li>Expressions in functions behave as though they were discrete-time
expressions.</li>
</ul>
<p>For an equation <code class="docutils literal highlight highlight-modelica"><span class="n">expr1</span> <span class="o">=</span> <span class="n">expr2</span></code> where neither expression is of base type
Real, both expressions must be discrete-time expressions. For record
equations the equation is split into basic types before applying this
test. [<em>This restriction guarantees that the</em> <code class="docutils literal highlight highlight-modelica"><span class="nb">noEvent</span><span class="p">()</span></code> <em>operator cannot
be applied to</em> <code class="docutils literal highlight highlight-modelica"><span class="nb">Boolean</span></code><em>,</em> <code class="docutils literal highlight highlight-modelica"><span class="nb">Integer</span></code><em>,</em> <code class="docutils literal highlight highlight-modelica"><span class="nb">String</span></code><em>, or enumeration
equations outside of a when-clause, because then one of the two
expressions is not discrete-time</em>]</p>
<p>Inside an if-expression, if-clause, while-statement or for-clause, that
is controlled by a non-discrete-time (that is continuous-time, but not
discrete-time) switching expression and not in the body of a
when-clause, it is not legal to have assignments to discrete variables,
equations between discrete-time expressions, or real elementary
relations/functions that should generate events. [<em>This restriction is
necessary in order to guarantee that there all equations for discrete
variable are discrete-time expressions, and to ensure that crossing
functions do not become active between events.</em>]</p>
<p>[<em>Example</em>:</p>
<div class="highlight-modelica"><div class="highlight"><pre><span class="kr">model</span> <span class="nc">Constants</span>
  <span class="kr">parameter</span> <span class="nb">Real</span> <span class="n">p1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kr">constant</span> <span class="nb">Real</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// error, no constant expression</span>
  <span class="kr">parameter</span> <span class="nb">Real</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// fine</span>
<span class="kr">end</span> <span class="nc">Constants</span><span class="p">;</span>

<span class="kr">model</span> <span class="nc">Test</span>
  <span class="n">Constants</span> <span class="n">c1</span><span class="p">(</span><span class="n">p1</span><span class="o">=</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// fine</span>
  <span class="n">Constants</span> <span class="n">c2</span><span class="p">(</span><span class="n">p2</span><span class="o">=</span><span class="mi">7</span><span class="p">);</span> <span class="c1">// fine, declaration equation can be modified</span>
  <span class="nb">Boolean</span> <span class="n">b</span><span class="p">;</span>
  <span class="nb">Real</span> <span class="n">x</span><span class="p">;</span>
<span class="kr">equation</span>
  <span class="n">b</span> <span class="o">=</span> <span class="nb">noEvent</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// error, since b is a discrete-time expr. and</span>
  <span class="c1">// noEvent(x &gt; 1) is not a discrete-time expr.</span>
<span class="kr">end</span> <span class="nc">Test</span><span class="p">;</span>
</pre></div>
</div>
<p>]</p>
</div>
<div class="section" id="continuous-time-expressions">
<h3>Continuous-Time Expressions<a class="headerlink" href="#continuous-time-expressions" title="Permalink to this headline">¶</a></h3>
<p>All expressions are continuous-time expressions including constant,
parameter and discrete expressions. The term “non-discrete-time
expression” refers to expressions that are not constant, parameter or
discrete expressions.</p>
<table class="docutils footnote" frame="void" id="matlab-mathematica" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first">MATLAB is a registered trademark of MathWorks Inc.</p>
<p class="last">Mathematica is a registered trademark of Wolfram Research Inc.</p>
</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Operators and Expressions</a><ul>
<li><a class="reference internal" href="#expressions">Expressions</a></li>
<li><a class="reference internal" href="#operator-precedence-and-associativity">Operator Precedence and Associativity</a></li>
<li><a class="reference internal" href="#evaluation-order">Evaluation Order</a><ul>
<li><a class="reference internal" href="#example-guarding-expressions-against-incorrect-evaluation">Example: Guarding Expressions Against Incorrect Evaluation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#arithmetic-operators">Arithmetic Operators</a></li>
<li><a class="reference internal" href="#equality-relational-and-logical-operators">Equality, Relational, and Logical Operators</a></li>
<li><a class="reference internal" href="#miscellaneous-operators-and-variables">Miscellaneous Operators and Variables</a><ul>
<li><a class="reference internal" href="#string-concatenation">String Concatenation</a></li>
<li><a class="reference internal" href="#array-constructor-operator">Array Constructor Operator</a></li>
<li><a class="reference internal" href="#array-concatenation-operator">Array Concatenation Operator</a></li>
<li><a class="reference internal" href="#array-range-operator">Array Range Operator</a></li>
<li><a class="reference internal" href="#if-expressions">If-Expressions</a></li>
<li><a class="reference internal" href="#member-access-operator">Member Access Operator</a></li>
<li><a class="reference internal" href="#built-in-variable-time">Built-in Variable time</a></li>
</ul>
</li>
<li><a class="reference internal" href="#built-in-intrinsic-operators-with-function-syntax">Built-in Intrinsic Operators with Function Syntax</a><ul>
<li><a class="reference internal" href="#numeric-functions-and-conversion-functions">Numeric Functions and Conversion Functions</a><ul>
<li><a class="reference internal" href="#event-triggering-mathematical-functions">Event Triggering Mathematical Functions</a><ul>
<li><a class="reference internal" href="#div-x-y">div(x,y)</a></li>
<li><a class="reference internal" href="#mod-x-y">mod(x,y)</a></li>
<li><a class="reference internal" href="#rem-x-y">rem(x,y)</a></li>
<li><a class="reference internal" href="#ceil-x">ceil(x)</a></li>
<li><a class="reference internal" href="#floor-x">floor(x)</a></li>
<li><a class="reference internal" href="#integer-x">integer(x)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#built-in-mathematical-functions-and-external-built-in-functions">Built-in Mathematical Functions and External Built-in Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#derivative-and-special-purpose-operators-with-function-syntax">Derivative and Special Purpose Operators with Function Syntax</a><ul>
<li><a class="reference internal" href="#delay">delay</a></li>
<li><a class="reference internal" href="#spatialdistribution">spatialDistribution</a></li>
<li><a class="reference internal" href="#cardinality-deprecated">cardinality (deprecated)</a></li>
<li><a class="reference internal" href="#homotopy">homotopy</a></li>
<li><a class="reference internal" href="#semilinear">semiLinear</a></li>
<li><a class="reference internal" href="#getinstancename">getInstanceName</a></li>
</ul>
</li>
<li><a class="reference internal" href="#event-related-operators-with-function-syntax">Event-Related Operators with Function Syntax</a><ul>
<li><a class="reference internal" href="#pre">pre</a></li>
<li><a class="reference internal" href="#noevent-and-smooth">noEvent and smooth</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#variability-of-expressions">Variability of Expressions</a><ul>
<li><a class="reference internal" href="#constant-expressions">Constant Expressions</a></li>
<li><a class="reference internal" href="#parameter-expressions">Parameter Expressions</a></li>
<li><a class="reference internal" href="#discrete-time-expressions">Discrete-Time Expressions</a></li>
<li><a class="reference internal" href="#continuous-time-expressions">Continuous-Time Expressions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="lexical.html"
                        title="previous chapter">Lexical Structure</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/operators.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Modelica Association.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.4</a>
      
      |
      <a href="_sources/operators.txt"
          rel="nofollow">Page source</a></li>
    </div>

    

    
  </body>
</html>